var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var createImage_exports = {};
__export(createImage_exports, {
  createImage: () => createImage
});
module.exports = __toCommonJS(createImage_exports);
var import_web = require("@tamagui/web"), import_jsx_runtime = require("react/jsx-runtime");
const defaultObjectFitMap = (objectFit) => {
  switch (objectFit) {
    case "fill":
      return "stretch";
    case "none":
      return "center";
    case "scale-down":
      return "contain";
    case "contain":
      return "contain";
    default:
      return "cover";
  }
}, defaultTransformSource = (props) => {
  const { src, source, width, height } = props;
  return source || (src && typeof src != "string" ? src : {
    uri: src,
    width,
    height
  });
};
function createImage(options) {
  const {
    Component,
    mapObjectFitToResizeMode = defaultObjectFitMap,
    resizeModePropName = "resizeMode",
    objectPositionPropName,
    transformSource = defaultTransformSource
  } = options, ImageComponent = (0, import_web.styled)(
    Component,
    {
      name: "Image"
    },
    {
      inlineProps: /* @__PURE__ */ new Set([
        "source",
        "placeholder",
        "transition",
        "contentFit",
        "contentPosition",
        "cachePolicy",
        "recyclingKey",
        "allowDownscaling",
        "autoplay",
        "blurRadius",
        "priority",
        "placeholderContentFit",
        "responsivePolicy",
        "onLoadStart",
        "onProgress",
        "onLoadEnd"
      ])
    }
  ).styleable((incomingProps, ref) => {
    const props = incomingProps, {
      src,
      width,
      height,
      objectFit,
      objectPosition,
      // web only props - filter out on native
      decoding,
      elementTiming,
      fetchpriority,
      isMap,
      loading,
      sizes,
      useMap,
      onLoad,
      onError,
      ...rest
    } = props, resolvedWidth = typeof width == "string" && width[0] === "$" ? (0, import_web.getTokenValue)(width) : width, resolvedHeight = typeof height == "string" && height[0] === "$" ? (0, import_web.getTokenValue)(height) : height, finalSource = transformSource({
      src,
      width: resolvedWidth,
      height: resolvedHeight
    }), finalProps = {
      ...rest,
      source: finalSource,
      style: {
        width: resolvedWidth,
        height: resolvedHeight
      }
    };
    return objectFit && (finalProps[resizeModePropName] = mapObjectFitToResizeMode(objectFit)), objectPositionPropName && objectPosition && (finalProps[objectPositionPropName] = objectPosition), onLoad && (finalProps.onLoad = (e) => {
      const source = e?.nativeEvent?.source || e?.source || {};
      onLoad({
        target: {
          naturalHeight: source?.height,
          naturalWidth: source?.width
        },
        type: "load"
      });
    }), onError && (finalProps.onError = () => {
      onError({
        type: "error"
      });
    }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, { ref, ...finalProps });
  }), comp = Component;
  return ImageComponent.getSize = comp.getSize || (() => {
  }), ImageComponent.getSizeWithHeaders = comp.getSizeWithHeaders || (() => {
  }), ImageComponent.prefetch = comp.prefetch || (() => {
  }), ImageComponent.prefetchWithMetadata = comp.prefetchWithMetadata || (() => {
  }), ImageComponent.abortPrefetch = comp.abortPrefetch || (() => {
  }), ImageComponent.queryCache = comp.queryCache || (() => {
  }), ImageComponent;
}
//# sourceMappingURL=createImage.js.map
