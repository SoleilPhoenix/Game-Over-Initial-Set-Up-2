"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf,
  __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
      get: all[name],
      enumerable: !0
    });
  },
  __copyProps = (to, from, except, desc) => {
    if (from && typeof from == "object" || typeof from == "function") for (let key of __getOwnPropNames(from)) !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    });
    return to;
  };
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: !0
  }) : target, mod)),
  __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
    value: !0
  }), mod);
var ToastImpl_exports = {};
__export(ToastImpl_exports, {
  ToastImpl: () => ToastImpl,
  ToastImplFrame: () => ToastImplFrame,
  useToastInteractiveContext: () => useToastInteractiveContext
});
module.exports = __toCommonJS(ToastImpl_exports);
var import_jsx_runtime = require("react/jsx-runtime"),
  import_animate_presence = require("@tamagui/animate-presence"),
  import_compose_refs = require("@tamagui/compose-refs"),
  import_constants = require("@tamagui/constants"),
  import_core = require("@tamagui/core"),
  import_dismissable = require("@tamagui/dismissable"),
  import_helpers = require("@tamagui/helpers"),
  import_portal = require("@tamagui/portal"),
  import_stacks = require("@tamagui/stacks"),
  React = __toESM(require("react"), 1),
  import_react_native = require("react-native"),
  import_constants2 = require("./constants.native.js"),
  import_ToastAnnounce = require("./ToastAnnounce.native.js"),
  import_ToastProvider = require("./ToastProvider.native.js"),
  import_ToastViewport = require("./ToastViewport.native.js"),
  ToastImplFrame = (0, import_core.styled)(import_stacks.ThemeableStack, {
    name: "ToastImpl",
    focusable: !0,
    variants: {
      unstyled: {
        false: {
          focusStyle: {
            outlineStyle: "solid",
            outlineWidth: 2,
            outlineColor: "$outlineColor"
          },
          backgroundColor: "$color6",
          borderRadius: "$10",
          paddingHorizontal: "$5",
          paddingVertical: "$2",
          marginHorizontal: "auto",
          marginVertical: "$1"
        }
      }
    },
    defaultVariants: {
      unstyled: process.env.TAMAGUI_HEADLESS === "1"
    }
  }),
  {
    Provider: ToastInteractiveProvider,
    useStyledContext: useToastInteractiveContext
  } = (0, import_core.createStyledContext)({
    onClose() {}
  }),
  ToastImpl = /* @__PURE__ */React.forwardRef(function (props, forwardedRef) {
    var {
        scope,
        type = "foreground",
        duration: durationProp,
        open,
        onClose,
        onEscapeKeyDown,
        onPause,
        onResume,
        onSwipeStart,
        onSwipeMove,
        onSwipeCancel,
        onSwipeEnd,
        viewportName = "default",
        ...toastProps
      } = props,
      isPresent = (0, import_animate_presence.useIsPresent)(),
      context = (0, import_ToastProvider.useToastProviderContext)(scope),
      [node, setNode] = React.useState(null),
      composedRefs = (0, import_compose_refs.useComposedRefs)(forwardedRef, setNode),
      duration = durationProp || context.duration,
      closeTimerStartTimeRef = React.useRef(0),
      closeTimerRemainingTimeRef = React.useRef(duration),
      closeTimerRef = React.useRef(0),
      {
        onToastAdd,
        onToastRemove
      } = context,
      viewport = React.useMemo(function () {
        return context.viewports[viewportName];
      }, [context.viewports, viewportName]),
      handleClose = (0, import_core.useEvent)(function () {
        if (isPresent) {
          if (import_constants.isWeb) {
            var isFocusInToast = node?.contains(document.activeElement);
            isFocusInToast && viewport?.focus();
          }
          onClose();
        }
      }),
      startTimer = React.useCallback(function (duration2) {
        !duration2 || duration2 === Number.POSITIVE_INFINITY || (clearTimeout(closeTimerRef.current), closeTimerStartTimeRef.current = (/* @__PURE__ */new Date()).getTime(), closeTimerRef.current = setTimeout(handleClose, duration2));
      }, [handleClose]),
      handleResume = React.useCallback(function () {
        startTimer(closeTimerRemainingTimeRef.current), onResume?.();
      }, [onResume, startTimer]),
      handlePause = React.useCallback(function () {
        var elapsedTime = (/* @__PURE__ */new Date()).getTime() - closeTimerStartTimeRef.current;
        closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime, window.clearTimeout(closeTimerRef.current), onPause?.();
      }, [onPause]);
    React.useEffect(function () {
      if (import_constants.isWeb && viewport) return viewport.addEventListener(import_ToastViewport.VIEWPORT_PAUSE, handlePause), viewport.addEventListener(import_ToastViewport.VIEWPORT_RESUME, handleResume), function () {
        viewport.removeEventListener(import_ToastViewport.VIEWPORT_PAUSE, handlePause), viewport.removeEventListener(import_ToastViewport.VIEWPORT_RESUME, handleResume);
      };
    }, [viewport, duration, onPause, onResume, startTimer]), React.useEffect(function () {
      open && !context.isClosePausedRef.current && startTimer(duration);
    }, [open, duration, context.isClosePausedRef, startTimer]), React.useEffect(function () {
      return onToastAdd(), function () {
        return onToastRemove();
      };
    }, [onToastAdd, onToastRemove]);
    var announceTextContent = React.useMemo(function () {
        return import_constants.isWeb && node ? getAnnounceTextContent(node) : null;
      }, [node]),
      isHorizontalSwipe = ["left", "right", "horizontal"].includes(context.swipeDirection),
      {
        animationDriver
      } = (0, import_core.useConfiguration)();
    if (!animationDriver) throw new Error("Must set animations in tamagui.config.ts");
    var {
        useAnimatedNumber,
        useAnimatedNumberStyle
      } = animationDriver,
      animatedNumber = useAnimatedNumber(0),
      _animationDriver_NumberView,
      _ref,
      AnimatedView = (_ref = (_animationDriver_NumberView = animationDriver.NumberView) !== null && _animationDriver_NumberView !== void 0 ? _animationDriver_NumberView : animationDriver.View) !== null && _ref !== void 0 ? _ref : import_core.Stack,
      animatedStyles = useAnimatedNumberStyle(animatedNumber, function (val) {
        "worklet";

        return {
          transform: [isHorizontalSwipe ? {
            translateX: val
          } : {
            translateY: val
          }]
        };
      }),
      panResponder = React.useMemo(function () {
        return import_react_native.PanResponder.create({
          onMoveShouldSetPanResponder: function (e, gesture) {
            var shouldMove = shouldGrantGestureMove(context.swipeDirection, gesture);
            return shouldMove ? (onSwipeStart?.(e), !0) : !1;
          },
          onPanResponderGrant: function (e) {
            import_constants.isWeb || handlePause?.();
          },
          onPanResponderMove: function (e, gesture) {
            var {
                x,
                y
              } = getGestureDistance(context.swipeDirection, gesture),
              delta = {
                x,
                y
              };
            animatedNumber.setValue(isHorizontalSwipe ? x : y, {
              type: "direct"
            }), isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold) && onSwipeEnd?.(e), onSwipeMove?.(e);
          },
          onPanResponderEnd: function (e, param) {
            var {
              dx,
              dy
            } = param;
            isDeltaInDirection({
              x: dx,
              y: dy
            }, context.swipeDirection, context.swipeThreshold) || (import_constants.isWeb || handleResume?.(), onSwipeCancel?.(e), animatedNumber.setValue(0, {
              type: "spring"
            }));
          }
        });
      }, [handlePause, handleResume]),
      themeName = (0, import_core.useThemeName)();
    return /* @__PURE__ */(0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [announceTextContent && /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_ToastAnnounce.ToastAnnounce, {
        scope,
        // Toasts are always role=status to avoid stuttering issues with role=alert in SRs.
        // biome-ignore lint/a11y/useSemanticElements: <explanation>
        role: "status",
        "aria-live": type === "foreground" ? "assertive" : "polite",
        "aria-atomic": !0,
        children: announceTextContent
      }), /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_portal.PortalItem, {
        hostName: viewportName ?? "default",
        children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(ToastInteractiveProvider, {
          scope,
          onClose: function () {
            handleClose();
          },
          children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_dismissable.Dismissable, {
            // asChild
            onEscapeKeyDown: (0, import_helpers.composeEventHandlers)(onEscapeKeyDown, function () {
              context.isFocusedToastEscapeKeyDownRef.current || handleClose(), context.isFocusedToastEscapeKeyDownRef.current = !1;
            }),
            children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_core.Theme, {
              contain: !0,
              forceClassName: !0,
              name: themeName,
              children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(AnimatedView, {
                ...panResponder?.panHandlers,
                style: [{
                  margin: "auto"
                }, animatedStyles],
                children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_ToastProvider.Collection.ItemSlot, {
                  scope: context.toastScope,
                  children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(ToastImplFrame, {
                    // Ensure toasts are announced as status list or status when focused
                    role: "status",
                    "aria-live": "off",
                    "aria-atomic": !0,
                    "data-state": open ? "open" : "closed",
                    "data-swipe-direction": context.swipeDirection,
                    pointerEvents: "auto",
                    touchAction: "none",
                    userSelect: "none",
                    ...toastProps,
                    ref: composedRefs,
                    ...(import_constants.isWeb && {
                      onKeyDown: (0, import_helpers.composeEventHandlers)(props.onKeyDown, function (event) {
                        event.key === "Escape" && (onEscapeKeyDown?.(event), onEscapeKeyDown?.(event), event.defaultPrevented || (context.isFocusedToastEscapeKeyDownRef.current = !0, handleClose()));
                      })
                    })
                  })
                })
              })
            })
          })
        }, props.id)
      })]
    });
  });
ToastImpl.propTypes = {
  type(props) {
    if (props.type && !["foreground", "background"].includes(props.type)) {
      var error = `Invalid prop \`type\` supplied to \`${import_constants2.TOAST_NAME}\`. Expected \`foreground | background\`.`;
      return new Error(error);
    }
    return null;
  }
};
var isDeltaInDirection = function (delta, direction) {
  var threshold = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
    deltaX = Math.abs(delta.x),
    deltaY = Math.abs(delta.y),
    isDeltaX = deltaX > deltaY;
  return direction === "left" || direction === "right" || direction === "horizontal" ? isDeltaX && deltaX > threshold : !isDeltaX && deltaY > threshold;
};
function getAnnounceTextContent(container) {
  if (!import_constants.isWeb) return "";
  var textContent = [],
    childNodes = Array.from(container.childNodes);
  return childNodes.forEach(function (node) {
    if (node.nodeType === node.TEXT_NODE && node.textContent && textContent.push(node.textContent), isHTMLElement(node)) {
      var isHidden = node.ariaHidden || node.hidden || node.style.display === "none",
        isExcluded = node.dataset.toastAnnounceExclude === "";
      if (!isHidden) if (isExcluded) {
        var altText = node.dataset.toastAnnounceAlt;
        altText && textContent.push(altText);
      } else textContent.push(...getAnnounceTextContent(node));
    }
  }), textContent;
}
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
var GESTURE_GRANT_THRESHOLD = 10,
  shouldGrantGestureMove = function (dir, param) {
    var {
      dx,
      dy
    } = param;
    return (dir === "horizontal" || dir === "left") && dx < -GESTURE_GRANT_THRESHOLD || (dir === "horizontal" || dir === "right") && dx > GESTURE_GRANT_THRESHOLD || (dir === "vertical" || dir === "up") && dy > -GESTURE_GRANT_THRESHOLD || (dir === "vertical" || dir === "down") && dy < GESTURE_GRANT_THRESHOLD;
  },
  getGestureDistance = function (dir, param) {
    var {
        dx,
        dy
      } = param,
      y = 0,
      x = 0;
    return dir === "horizontal" ? x = dx : dir === "left" ? x = Math.min(0, dx) : dir === "right" ? x = Math.max(0, dx) : dir === "vertical" ? y = dy : dir === "up" ? y = Math.min(0, dy) : dir === "down" && (y = Math.max(0, dy)), {
      x,
      y
    };
  };
//# sourceMappingURL=ToastImpl.native.js.map
