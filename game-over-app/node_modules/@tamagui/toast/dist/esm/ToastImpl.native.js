import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useIsPresent } from "@tamagui/animate-presence";
import { useComposedRefs } from "@tamagui/compose-refs";
import { isWeb } from "@tamagui/constants";
import { Stack, Theme, createStyledContext, styled, useConfiguration, useEvent, useThemeName } from "@tamagui/core";
import { Dismissable } from "@tamagui/dismissable";
import { composeEventHandlers } from "@tamagui/helpers";
import { PortalItem } from "@tamagui/portal";
import { ThemeableStack } from "@tamagui/stacks";
import * as React from "react";
import { PanResponder } from "react-native";
import { TOAST_NAME } from "./constants.native.js";
import { ToastAnnounce } from "./ToastAnnounce.native.js";
import { Collection, useToastProviderContext } from "./ToastProvider.native.js";
import { VIEWPORT_PAUSE, VIEWPORT_RESUME } from "./ToastViewport.native.js";
var ToastImplFrame = styled(ThemeableStack, {
    name: "ToastImpl",
    focusable: !0,
    variants: {
      unstyled: {
        false: {
          focusStyle: {
            outlineStyle: "solid",
            outlineWidth: 2,
            outlineColor: "$outlineColor"
          },
          backgroundColor: "$color6",
          borderRadius: "$10",
          paddingHorizontal: "$5",
          paddingVertical: "$2",
          marginHorizontal: "auto",
          marginVertical: "$1"
        }
      }
    },
    defaultVariants: {
      unstyled: process.env.TAMAGUI_HEADLESS === "1"
    }
  }),
  {
    Provider: ToastInteractiveProvider,
    useStyledContext: useToastInteractiveContext
  } = createStyledContext({
    onClose() {}
  }),
  ToastImpl = /* @__PURE__ */React.forwardRef(function (props, forwardedRef) {
    var {
        scope,
        type = "foreground",
        duration: durationProp,
        open,
        onClose,
        onEscapeKeyDown,
        onPause,
        onResume,
        onSwipeStart,
        onSwipeMove,
        onSwipeCancel,
        onSwipeEnd,
        viewportName = "default",
        ...toastProps
      } = props,
      isPresent = useIsPresent(),
      context = useToastProviderContext(scope),
      [node, setNode] = React.useState(null),
      composedRefs = useComposedRefs(forwardedRef, setNode),
      duration = durationProp || context.duration,
      closeTimerStartTimeRef = React.useRef(0),
      closeTimerRemainingTimeRef = React.useRef(duration),
      closeTimerRef = React.useRef(0),
      {
        onToastAdd,
        onToastRemove
      } = context,
      viewport = React.useMemo(function () {
        return context.viewports[viewportName];
      }, [context.viewports, viewportName]),
      handleClose = useEvent(function () {
        if (isPresent) {
          if (isWeb) {
            var isFocusInToast = node?.contains(document.activeElement);
            isFocusInToast && viewport?.focus();
          }
          onClose();
        }
      }),
      startTimer = React.useCallback(function (duration2) {
        !duration2 || duration2 === Number.POSITIVE_INFINITY || (clearTimeout(closeTimerRef.current), closeTimerStartTimeRef.current = (/* @__PURE__ */new Date()).getTime(), closeTimerRef.current = setTimeout(handleClose, duration2));
      }, [handleClose]),
      handleResume = React.useCallback(function () {
        startTimer(closeTimerRemainingTimeRef.current), onResume?.();
      }, [onResume, startTimer]),
      handlePause = React.useCallback(function () {
        var elapsedTime = (/* @__PURE__ */new Date()).getTime() - closeTimerStartTimeRef.current;
        closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime, window.clearTimeout(closeTimerRef.current), onPause?.();
      }, [onPause]);
    React.useEffect(function () {
      if (isWeb && viewport) return viewport.addEventListener(VIEWPORT_PAUSE, handlePause), viewport.addEventListener(VIEWPORT_RESUME, handleResume), function () {
        viewport.removeEventListener(VIEWPORT_PAUSE, handlePause), viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
      };
    }, [viewport, duration, onPause, onResume, startTimer]), React.useEffect(function () {
      open && !context.isClosePausedRef.current && startTimer(duration);
    }, [open, duration, context.isClosePausedRef, startTimer]), React.useEffect(function () {
      return onToastAdd(), function () {
        return onToastRemove();
      };
    }, [onToastAdd, onToastRemove]);
    var announceTextContent = React.useMemo(function () {
        return isWeb && node ? getAnnounceTextContent(node) : null;
      }, [node]),
      isHorizontalSwipe = ["left", "right", "horizontal"].includes(context.swipeDirection),
      {
        animationDriver
      } = useConfiguration();
    if (!animationDriver) throw new Error("Must set animations in tamagui.config.ts");
    var {
        useAnimatedNumber,
        useAnimatedNumberStyle
      } = animationDriver,
      animatedNumber = useAnimatedNumber(0),
      _animationDriver_NumberView,
      _ref,
      AnimatedView = (_ref = (_animationDriver_NumberView = animationDriver.NumberView) !== null && _animationDriver_NumberView !== void 0 ? _animationDriver_NumberView : animationDriver.View) !== null && _ref !== void 0 ? _ref : Stack,
      animatedStyles = useAnimatedNumberStyle(animatedNumber, function (val) {
        "worklet";

        return {
          transform: [isHorizontalSwipe ? {
            translateX: val
          } : {
            translateY: val
          }]
        };
      }),
      panResponder = React.useMemo(function () {
        return PanResponder.create({
          onMoveShouldSetPanResponder: function (e, gesture) {
            var shouldMove = shouldGrantGestureMove(context.swipeDirection, gesture);
            return shouldMove ? (onSwipeStart?.(e), !0) : !1;
          },
          onPanResponderGrant: function (e) {
            isWeb || handlePause?.();
          },
          onPanResponderMove: function (e, gesture) {
            var {
                x,
                y
              } = getGestureDistance(context.swipeDirection, gesture),
              delta = {
                x,
                y
              };
            animatedNumber.setValue(isHorizontalSwipe ? x : y, {
              type: "direct"
            }), isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold) && onSwipeEnd?.(e), onSwipeMove?.(e);
          },
          onPanResponderEnd: function (e, param) {
            var {
              dx,
              dy
            } = param;
            isDeltaInDirection({
              x: dx,
              y: dy
            }, context.swipeDirection, context.swipeThreshold) || (isWeb || handleResume?.(), onSwipeCancel?.(e), animatedNumber.setValue(0, {
              type: "spring"
            }));
          }
        });
      }, [handlePause, handleResume]),
      themeName = useThemeName();
    return /* @__PURE__ */_jsxs(_Fragment, {
      children: [announceTextContent && /* @__PURE__ */_jsx(ToastAnnounce, {
        scope,
        // Toasts are always role=status to avoid stuttering issues with role=alert in SRs.
        // biome-ignore lint/a11y/useSemanticElements: <explanation>
        role: "status",
        "aria-live": type === "foreground" ? "assertive" : "polite",
        "aria-atomic": !0,
        children: announceTextContent
      }), /* @__PURE__ */_jsx(PortalItem, {
        hostName: viewportName ?? "default",
        children: /* @__PURE__ */_jsx(ToastInteractiveProvider, {
          scope,
          onClose: function () {
            handleClose();
          },
          children: /* @__PURE__ */_jsx(Dismissable, {
            // asChild
            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, function () {
              context.isFocusedToastEscapeKeyDownRef.current || handleClose(), context.isFocusedToastEscapeKeyDownRef.current = !1;
            }),
            children: /* @__PURE__ */_jsx(Theme, {
              contain: !0,
              forceClassName: !0,
              name: themeName,
              children: /* @__PURE__ */_jsx(AnimatedView, {
                ...panResponder?.panHandlers,
                style: [{
                  margin: "auto"
                }, animatedStyles],
                children: /* @__PURE__ */_jsx(Collection.ItemSlot, {
                  scope: context.toastScope,
                  children: /* @__PURE__ */_jsx(ToastImplFrame, {
                    // Ensure toasts are announced as status list or status when focused
                    role: "status",
                    "aria-live": "off",
                    "aria-atomic": !0,
                    "data-state": open ? "open" : "closed",
                    "data-swipe-direction": context.swipeDirection,
                    pointerEvents: "auto",
                    touchAction: "none",
                    userSelect: "none",
                    ...toastProps,
                    ref: composedRefs,
                    ...(isWeb && {
                      onKeyDown: composeEventHandlers(props.onKeyDown, function (event) {
                        event.key === "Escape" && (onEscapeKeyDown?.(event), onEscapeKeyDown?.(event), event.defaultPrevented || (context.isFocusedToastEscapeKeyDownRef.current = !0, handleClose()));
                      })
                    })
                  })
                })
              })
            })
          })
        }, props.id)
      })]
    });
  });
ToastImpl.propTypes = {
  type(props) {
    if (props.type && !["foreground", "background"].includes(props.type)) {
      var error = `Invalid prop \`type\` supplied to \`${TOAST_NAME}\`. Expected \`foreground | background\`.`;
      return new Error(error);
    }
    return null;
  }
};
var isDeltaInDirection = function (delta, direction) {
  var threshold = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
    deltaX = Math.abs(delta.x),
    deltaY = Math.abs(delta.y),
    isDeltaX = deltaX > deltaY;
  return direction === "left" || direction === "right" || direction === "horizontal" ? isDeltaX && deltaX > threshold : !isDeltaX && deltaY > threshold;
};
function getAnnounceTextContent(container) {
  if (!isWeb) return "";
  var textContent = [],
    childNodes = Array.from(container.childNodes);
  return childNodes.forEach(function (node) {
    if (node.nodeType === node.TEXT_NODE && node.textContent && textContent.push(node.textContent), isHTMLElement(node)) {
      var isHidden = node.ariaHidden || node.hidden || node.style.display === "none",
        isExcluded = node.dataset.toastAnnounceExclude === "";
      if (!isHidden) if (isExcluded) {
        var altText = node.dataset.toastAnnounceAlt;
        altText && textContent.push(altText);
      } else textContent.push(...getAnnounceTextContent(node));
    }
  }), textContent;
}
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
var GESTURE_GRANT_THRESHOLD = 10,
  shouldGrantGestureMove = function (dir, param) {
    var {
      dx,
      dy
    } = param;
    return (dir === "horizontal" || dir === "left") && dx < -GESTURE_GRANT_THRESHOLD || (dir === "horizontal" || dir === "right") && dx > GESTURE_GRANT_THRESHOLD || (dir === "vertical" || dir === "up") && dy > -GESTURE_GRANT_THRESHOLD || (dir === "vertical" || dir === "down") && dy < GESTURE_GRANT_THRESHOLD;
  },
  getGestureDistance = function (dir, param) {
    var {
        dx,
        dy
      } = param,
      y = 0,
      x = 0;
    return dir === "horizontal" ? x = dx : dir === "left" ? x = Math.min(0, dx) : dir === "right" ? x = Math.max(0, dx) : dir === "vertical" ? y = dy : dir === "up" ? y = Math.min(0, dy) : dir === "down" && (y = Math.max(0, dy)), {
      x,
      y
    };
  };
export { ToastImpl, ToastImplFrame, useToastInteractiveContext };
//# sourceMappingURL=ToastImpl.native.js.map
